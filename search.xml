<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot 整合mongodb实现CRUD]]></title>
    <url>%2Fposts%2F634f3968%2F</url>
    <content type="text"><![CDATA[MongoDB 简介MongoDB（来自于英文单词“Humongous”，中文含义为“庞大”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。基于分布式文件存储的数据库。由C++语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个高性能，开源，无模式的文档型数据库，是当前 NoSql 数据库中比较热门的一种。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似 json 的 bjson 格式，因此可以存储比较复杂的数据类型。MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 传统的关系数据库一般由数据库（database）、表（table）、记录（record）三个层次概念组成，MongoDB 是由数据库（database）、集合（collection）、文档对象（document）三个层次组成。MongoDB 对于关系型数据库里的表，但是集合中没有列、行和关系概念，这体现了模式自由的特点。 MongoDB 中的一条记录就是一个文档，是一个数据结构，由字段和值对组成。MongoDB 文档与 JSON 对象类似。字段的值有可能包括其它文档、数组以及文档数组。MongoDB 支持 OS X、Linux 及 Windows 等操作系统，并提供了 Python，PHP，Ruby，Java及 C++ 语言的驱动程序，社区中也提供了对 Erlang 及 .NET 等平台的驱动程序。 MongoDB 的适合对大量或者无固定格式的数据进行存储，比如：日志、缓存等。对事物支持较弱，不适用复杂的多文档（多表）的级联查询。 配置maven依赖配置在pom文件的dependencies节点中增加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; application配置在项目的application.yml配置文件中加入mongodb服务地址，集群模式配置将地址用逗号隔开即可，举例如下： 12345# mongodbspring: data: mongodb: uri: mongodb://username:password@ip:port,ip2:port,ip3:port3/databaseName spring boot 启动类配置在spring boot项目启动类上增加注解@EnableMongoRepositories，basePackages指定需要扫描的包路径： 123456789@SpringBootApplication()@EnableMongoRepositories(basePackages = &#123;"com.xxx.xxx.xx.xxxx.repository"&#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication app = new SpringApplication(Application.class); app.addListeners(new AppStartedListener()); app.run(args); &#125;&#125; MongoDB 增删改查直接继承MongoRepository实现增删改查首先创建实体类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Document(collection = "SysOperateRecord")@Datapublic class SysOperateRecord implements Serializable &#123; @Id private String id; /** * 操作类型:参数管理，仓库管理，子仓管理，库区管理，货位管理，包裹管理，波次管理， */ private String operateCode; /** * 操作类型名称 */ private String operateName; /** * 操作的记录ID */ @Indexed private Integer operateId; /** * 操作内容 */ private String operateContent; /** * 操作人 */ private String operateUser; /** * 备注 */ private String remark; /** * 是否删除标记0 未删除 1 已删除 */ private Boolean isDelete; /** * 创建时间 */ private Date createTime; /** * 更新时间 */ private Date lastUpdateTime; /** * 操作前 */ private String operateBefore; private static final long serialVersionUID = 1L;&#125; 其中 @Document：标识该类为mongodb文档类，设置的collection名会直接映射到mongodb中 @id：标识字段为主键id @Indexed：以该字段创建索引 更多注解请参考官方文档 新建xxxRepository类继承MongoRepository： 1234@Repositorypublic interface SysOperateRecordRepository extends MongoRepository&lt;SysOperateRecord, String&gt;&#123; &#125; 在MongoRepository接口中提供了一系列的增删改查接口如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@NoRepositoryBeanpublic interface MongoRepository&lt;T, ID extends Serializable&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123; /* * (non-Javadoc) * @see org.springframework.data.repository.CrudRepository#save(java.lang.Iterable) */ @Override &lt;S extends T&gt; List&lt;S&gt; save(Iterable&lt;S&gt; entites); /* * (non-Javadoc) * @see org.springframework.data.repository.CrudRepository#findAll() */ @Override List&lt;T&gt; findAll(); /* * (non-Javadoc) * @see org.springframework.data.repository.PagingAndSortingRepository#findAll(org.springframework.data.domain.Sort) */ @Override List&lt;T&gt; findAll(Sort sort); /** * Inserts the given entity. Assumes the instance to be new to be able to apply insertion optimizations. Use * the returned instance for further operations as the save operation might have changed the entity instance * completely. Prefer using &#123;@link #save(Object)&#125; instead to avoid the usage of store-specific API. * * @param entity must not be &#123;@literal null&#125;. * @return the saved entity * @since 1.7 */ &lt;S extends T&gt; S insert(S entity); /** * Inserts the given entities. Assumes the given entities to have not been persisted yet and thus will optimize the * insert over a call to &#123;@link #save(Iterable)&#125;. Prefer using &#123;@link #save(Iterable)&#125; to avoid the usage of store * specific API. * * @param entities must not be &#123;@literal null&#125;. * @return the saved entities * @since 1.7 */ &lt;S extends T&gt; List&lt;S&gt; insert(Iterable&lt;S&gt; entities); /* * (non-Javadoc) * @see org.springframework.data.repository.query.QueryByExampleExecutor#findAll(org.springframework.data.domain.Example) */ @Override &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; example); /* * (non-Javadoc) * @see org.springframework.data.repository.query.QueryByExampleExecutor#findAll(org.springframework.data.domain.Example, org.springframework.data.domain.Sort) */ @Override &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; example, Sort sort);&#125; 通过调用save方法，可以实现批量新增和修改记录。当记录存在时会自动更新记录，不存在则新增记录。 通过调用insert方法，可以实现新增或者批量新增记录。 通过调用findAll方法，可以实现查询记录。 同时，MongoRepository还继承了PagingAndSortingRepository和QueryByExampleExecutor，分别提供了分页查询方法和基于Example查询的方法。 使用举例： 123456789101112131415161718192021222324252627282930313233343536373839//调用insert方法新增记录SysOperateRecord sysOperateRecord = new SysOperateRecord();sysOperateRecord.setOperateCode(operateType.getCode());sysOperateRecord.setOperateName(operateType.getDescription());sysOperateRecord.setOperateId(i);sysOperateRecord.setOperateContent(operateType.getDescription());sysOperateRecord.setOperateUser("root");sysOperateRecord.setRemark(operateType.getDescription());sysOperateRecordRepository.insert(sysOperateRecords); //insert支持传入list批量新增//调用save方法新增记录SysOperateRecord sysOperateRecord = new SysOperateRecord();sysOperateRecord.setOperateCode(operateType.getCode());sysOperateRecord.setOperateName(operateType.getDescription());sysOperateRecord.setOperateId(i);sysOperateRecord.setOperateContent(operateType.getDescription());sysOperateRecord.setOperateUser("root");sysOperateRecord.setRemark(operateType.getDescription());sysOperateRecordRepository.save(sysOperateRecords); //save支持传入list批量新增//调用save方法更新记录SysOperateRecord sysOperateRecord = new SysOperateRecord();sysOperateRecord.setId("xxxxx"); //id在mongodb collection中已经存在sysOperateRecord.setOperateCode(operateType.getCode());sysOperateRecord.setOperateName(operateType.getDescription());sysOperateRecord.setOperateId(i);sysOperateRecord.setOperateContent(operateType.getDescription());sysOperateRecord.setOperateUser("root");sysOperateRecord.setRemark(operateType.getDescription());sysOperateRecordRepository.save(sysOperateRecords); //save支持传入list批量更新//使用delete方法删除记录sysOperateRecordRepository.delete("sss");//删除id为sss的记录//调用findAll查询记录SysOperateRecord sysOperateRecord = new SysOperateRecord();sysOperateRecord.setOperateCode("AAA");sysOperateRecord.setOperateId(1);sysOperateRecordRepository.findAll(Example.of(sysOperateRecord), new Sort(Sort.Direction.DESC, "createTime")); //查询OperateCode为AAA且OperateId为1的记录，根据createTime倒序排序 此外在xxxRepository中，我们可以自定义方法进行查询： 1234567/** * 根据操作id查询记录 * * @param operateId * @return */ List&lt;SysOperateRecord&gt; findByOperateId(Integer operateId); 更多用法请参考spring data jpa 使用@Query注解在上一节中，我们直接继承MongoRepository，使用框架内置的查询方法可以进行一些简单查询。奈何在实际使用时，我们会使用像IN这种操作，如果查询限制条件非常多的话，可能我们会自定义如下方法： 1List&lt;SysOperateRecord&gt; findByOperateCodeAndOperateBeforeAndOperateContentAndOperateIdIn(String operateCode,String operateBefore, String operateContent, List&lt;Integer&gt; operateIds); 方法名会变的特别长，很难看也难以维护。 此时我们可以使用@Query注解 12@Query(value = "&#123;operateCode: ?0, operateBefore:?1,operateContent:?2,operateId:&#123;$in: ?3&#125;, isDelete:false&#125;") List&lt;SysOperateRecord&gt; find(String operateCode,String operateBefore, String operateContent, List&lt;Integer&gt; operateIds); 注解value字段直接写入json形式的字符串，占位符？0表方法第一个参数，以此类推。 使用Querydsl上节我们使用@Query注解解决了方法名过长的问题，有心的小伙伴会发现，使用注解还是会存在俩个问题： 我们必须对manogo原生查询非常熟悉才能很快写出json字符串 当查询的条件很多时，方法参数也会变的很多，易读性差，使用性也差 那么有没有更优雅的方式来进行复杂条件查询呢，of course。 Querydsl简介官方介绍如下： 123Querydsl is a framework which enables the construction of type-safe SQL-like queries for multiple backends including JPA, MongoDB and SQL in Java.Instead of writing queries as inline strings or externalizing them into XML files they are constructed via a fluent API. 大意就是使用这个类库，可以让我像写sql一样的去写java代码。免去了我们手动在字符串中或者xml中写原生sql的麻烦。听起来好像还不错，那么如何在spring项目中使用该类库呢？ 很简单，sping data对Querydsl进行了集成。咱们需要额外引入的是Querydsl对mongodb提供支持的类库。 pom文件配置1. 在pom文件的依赖中添加：1234&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 2. 添加apt插件12345678910111213141516171819202122232425&lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt; &lt;version&gt;$&#123;querydsl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/queries&lt;/outputDirectory&gt; &lt;processor&gt;org.springframework.data.mongodb.repository.support.MongoAnnotationProcessor&lt;/processor&gt; &lt;logOnlyOnError&gt;true&lt;/logOnlyOnError&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 执行mave编译命令执行maven命令： 1mvn clean compile 执行完毕后，在target/generated-sources/queries包下会生成Q开头的实体类。本文中即为QSysOperateRecord，该类是由maven插件自动生成的。插件会为带@Document注解的类自动生成QXXX。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * QSysOperateRecord is a Querydsl query type for SysOperateRecord */@Generated("com.querydsl.codegen.EntitySerializer")public class QSysOperateRecord extends EntityPathBase&lt;SysOperateRecord&gt; &#123; private static final long serialVersionUID = -643412538L; public static final QSysOperateRecord sysOperateRecord = new QSysOperateRecord("sysOperateRecord"); public final DateTimePath&lt;java.util.Date&gt; createTime = createDateTime("createTime", java.util.Date.class); public final StringPath id = createString("id"); public final BooleanPath isDelete = createBoolean("isDelete"); public final DateTimePath&lt;java.util.Date&gt; lastUpdateTime = createDateTime("lastUpdateTime", java.util.Date.class); public final StringPath operateBefore = createString("operateBefore"); public final StringPath operateCode = createString("operateCode"); public final StringPath operateContent = createString("operateContent"); public final NumberPath&lt;Integer&gt; operateId = createNumber("operateId", Integer.class); public final StringPath operateName = createString("operateName"); public final StringPath operateUser = createString("operateUser"); public final StringPath remark = createString("remark"); public QSysOperateRecord(String variable) &#123; super(SysOperateRecord.class, forVariable(variable)); &#125; public QSysOperateRecord(Path&lt;? extends SysOperateRecord&gt; path) &#123; super(path.getType(), path.getMetadata()); &#125; public QSysOperateRecord(PathMetadata metadata) &#123; super(SysOperateRecord.class, metadata); &#125;&#125; 使用方式1. xxxRepository继承QueryDslPredicateExecutor123@Repositorypublic interface SysOperateRecordRepository extends MongoRepository&lt;SysOperateRecord, String&gt;, QueryDslPredicateExecutor&lt;SysOperateRecord&gt; &#123;&#125; QueryDslPredicateExecutor中提供了对Querydsl的支持。 2. 使用举例查询举例： 123456789101112public List&lt;SysOperateRecord&gt; queryBy(String operateCode, List&lt;Integer&gt; operateIds) &#123; QSysOperateRecord qSysOperateRecord = QSysOperateRecord .sysOperateRecord; //通过链式的调用方式，组装查询条件 BooleanExpression condition = qSysOperateRecord.operateCode.eq(operateCode) .and(qSysOperateRecord.operateId.in(operateIds)) .and(qSysOperateRecord.isDelete.eq(false)); //调用findAll方法，传入查询条件和排序方式，排序方式支持多字段排序 Iterable&lt;SysOperateRecord&gt; records = sysOperateRecordRepository .findAll(condition, new QSort(qSysOperateRecord.createTime.desc())); return Lists.newArrayList(records);&#125; 分页查询举例： 1234567891011121314public List&lt;SysOperateRecord&gt; queryPageBy(String operateCode, List&lt;Integer&gt; operateIds, PageReq pageReq) &#123; QSysOperateRecord qSysOperateRecord = QSysOperateRecord .sysOperateRecord; BooleanExpression condition = qSysOperateRecord.operateCode.eq(operateCode) .and(qSysOperateRecord.operateId.in(operateIds)) .and(qSysOperateRecord.isDelete.eq(false)); Iterable&lt;SysOperateRecord&gt; records = sysOperateRecordRepository .findAll(condition, new QPageRequest( pageReq.getPageNum(), pageReq.getPageSize(), new QSort(qSysOperateRecord.createTime.desc()))); return Lists.newArrayList(records);&#125; 结语本文介绍了spring项目如何集成mongodb，并简要分析了几种查询方式的优缺点。基本结论如下： 简单查询直接使用repository内置api即可 复杂查询推荐使用Querydsl]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>mongodb</tag>
        <tag>spring data jpa</tag>
        <tag>querydsl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zuul 根据标签进行路由]]></title>
    <url>%2Fposts%2F6d250c8e%2F</url>
    <content type="text"><![CDATA[背景笔者所在部门为了响应公司的号召，需要建立灰度环境。那么既然有了灰度环境的概念，必然需要实现灰度发布。 而目前的网关zuul并不能实现我们的需求，需要对路由策略进行扩展。 目标网关根据指定的标签，转发请求到包含指定标签的服务节点上。 方案方案设计图如下： 实现实现步骤给服务打标签修改项目的配置文件，每台服务器都要配置。笔者所在公司使用consul做注册中心，故配置如下： 12345678spring: cloud: consul: port: 8500 host: xx.xx.xx.xx discovery: tags: - pro 启动成功后观察consul，出现相应标签，表示服务注册成功。 扩展路由策略负载均衡原理简析首先，我们查看zuul源码，发现其使用的是netfix提供的ribbon-loadbalancer来实现负载均衡。程序中使用的版本为2.2.5。阅读源码发现ribbon主要通过ILoadBalancer接口定义了一系列行为： 观察ILoadBalancer最基础的实现类com.netflix.loadbalancer.BaseLoadBalancer可以了解主要行为。LB的主要实现都在里面，DynamicServerListLoadBalancer和ZoneAwareLoadBalancer不过是扩展了他的功能而已。 可以看到一个LB中包含的几个重要的属性（工具），正是这几个工具为LB的功能提供支持。 他们是： 属性 描述 Iping 判断目标服务是否存活 对应不同的协议不同的方式去探测，得到后端服务是否存活。如有http的，还有对于微服务框架内的服务存活的NIWSDiscoveryPing是通过eureka client来获取的instanceinfo中的信息来获取。 IRule 负载均衡策略,可以插件化的为LB提供各种适用的负载均衡算法 LoadBalancerStats LB运行信息 记录LB的实时运行信息，这些运行信息可以被用来作为LB策略的输入。 观察下几个主要方法。首先是最重要的的服务选择方法： 可以看到将该功能委托给包含的负载均衡策略rule来实现。ok，下面我们来看一下Ribbon负载均衡策略定义： IRule其实就只做了一件事情Server choose(Object key)，可以看到这个功能是在LB中定义（要求）的，LB把这个功能委托给IRule来实现。不同的IRule可以向LB提供不同的负载均衡算法。 com.netflix.loadbalancer包下面的提供了常用的几种策略。有RoundRobinRule、RandomRule这样的不依赖于Server运行状况的策略，也有AvailabilityFilteringRule、WeightedResponseTimeRule等多种基于收集到的Server运行状况决策的策略。判断运行状况时有，判断单个server的，也有判断整个zone的，适用于各种不同场景需求。 实现上有些策略可以继承一个既存的简单策略用于某些启动时候，也可以包含一个简单策略。甚至有ZoneAvoidanceRule这样的可以包含复合谓词的条件判断。 详见ZoneAvoidanceRule源码： 其中组合了ZoneAvoidancePredicate和AvailabilityPredicate俩个谓词。前一个，以一个区域为单位考察可用性，对于不可用的区域整个丢弃，从剩下区域中选可用的server。判断出最差的区域，排除掉最差区域。在剩下的区域中，将按照服务器实例数的概率抽样法选择，从而判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。 我们看到ZoneAvoidanceRule中并没有重写choose方法，查看一下继承图： 在PredicateBasedRule中我们发现： 此处choose方法从lb中获取所有服务节点，然后针对具体实现类中的谓词（XXXPredicate）对服务节点进行过滤。继续跟踪最后发现执行至AbstractServerPredicate类中的代码： 此处对server列表进行了过滤，过滤谓词是后面的this.getServerOnlyPredicate该方法只是简单返回了serverOnlyPredicate： 此处可以发现，最终执行的谓词是具体子类定义的谓词，也就是ZoneAvoidanceRule的compositePredicate。 由此可见，我们只要按照ribbon的框架结构，提供自定义的负载均衡策略，实现具体的组合谓词，就可以实现根据标签来过滤服务节点。 实现自定义的负载均衡策略（ServiceTagsAwareRule）要实现自定义的负载均衡策略ServiceTagsAwareRule，我们先要实现它的谓词，首先建立一个抽象谓词类（BaseDiscoveryEnabledPredicate）： 12345678910111213141516171819202122232425262728293031 /** * A template method predicate to be applied to service discovered server instances. The concrete implementation of * this class need to implement the &#123;@link #apply(ConsulServer)&#125; method. * * @author yanjing * date: 2019/9/30 * description: */public abstract class BaseDiscoveryEnabledPredicate extends AbstractServerPredicate &#123; protected Logger logger = LoggerFactory.getLogger(this.getClass()); //此处做一下前置判断，不为空且是ConsulServer的实例，spring-cloud框架会自动将候选的服务节点从Server向下转型为ConsulServer @Override public boolean apply(PredicateKey input) &#123; return Objects.nonNull(input) &amp;&amp; input.getServer() instanceof ConsulServer &amp;&amp; apply((ConsulServer) input.getServer()); &#125; /** * Returns whether the specific &#123;@link ConsulServer&#125; matches this predicate. * * @param server the discovered server * @return whether the server matches the predicate */ protected abstract boolean apply(ConsulServer server);&#125; 再实现具体的谓词逻辑（ServiceTagsAwarePredicate）： 1234567891011121314151617181920212223 /** * A default implementation of &#123;@link ConsulServer&#125; that matches the instance against the attributes * registered through * * @author yanjing * date: 2019/9/30 * description: */public class ServiceTagsAwarePredicate extends BaseDiscoveryEnabledPredicate &#123; @Override protected boolean apply(ConsulServer server) &#123; final RibbonFilterContext context = RibbonFilterContextHolder.getCurrentContext(); final List&lt;String&gt; contextTags = context.getServiceTags(); //自定义的prefilter中指定的生产环境或灰度环境标签 final List&lt;String&gt; serviceTags = server.getHealthService().getService().getTags(); //候选服务节点的标签 boolean hit = CollectionUtils.isSubCollection(contextTags, serviceTags); //候选服务节点的标签列表中是否包含指定的环境标签 logger.info("ServiceTagsAwarePredicate contextTags:&#123;&#125;, serviceTags:&#123;&#125;,result: &#123;&#125;,server:&#123;&#125;", contextTags, serviceTags, hit, JsonTools.defaultMapper().toJson(server)); return hit; &#125;&#125; 接下来我们来实现负载均衡策略（ServiceTagsAwareRule）： 1234567891011121314151617181920212223242526272829303132333435363738 /** * @author yanjing * date: 2019/9/30 * description: */public class ServiceTagsAwareRule extends PredicateBasedRule &#123; private CompositePredicate predicate; /** * Creates new instance of &#123;@link ServiceTagsAwareRule&#125;. */ public ServiceTagsAwareRule() &#123; super(); predicate = createCompositePredicate(new ServiceTagsAwarePredicate(), new AvailabilityPredicate(this, null)); &#125; @Override public AbstractServerPredicate getPredicate() &#123; return predicate; &#125; /** * Creates the composite predicate with fallback strategies. * * @param discoveryEnabledPredicate the discovery service predicate * @param availabilityPredicate the availability predicate * @return the composite predicate */ private CompositePredicate createCompositePredicate(BaseDiscoveryEnabledPredicate discoveryEnabledPredicate, AvailabilityPredicate availabilityPredicate) &#123; return CompositePredicate .withPredicates(discoveryEnabledPredicate, availabilityPredicate) .addFallbackPredicate(availabilityPredicate) .build(); &#125;&#125; 将自定义的策略配置交给spring管理： 1234567891011121314151617181920 /** * The Ribbon discovery filter auto configuration. * * @author yanjing * date: 2019/9/30 * description: */@Configuration@AutoConfigureBefore(RibbonClientConfiguration.class)@ConditionalOnProperty(value = "ribbon.filter.tags.enabled", matchIfMissing = true)public class RibbonDiscoveryRuleAutoConfiguration &#123; @Bean @ConditionalOnMissingBean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public ServiceTagsAwareRule serviceTagsAwareRule() &#123; return new ServiceTagsAwareRule(); &#125;&#125; 自定义RibbonFilterContext: 1234567891011121314151617181920212223242526272829303132333435 /** * Ribbon discovery filter context,stores the tags based on which the server matching will be performed. * * @author yanjing * date: 2019/9/30 * description: */public interface RibbonFilterContext &#123; /** * 给上下文增加标签 * * @param tag 标签 * @return 上下文实例 */ RibbonFilterContext add(String tag); /** * 删除标签 * * @param tag 标签 * @return 上下文实例 */ RibbonFilterContext remove(String tag); /** * 获取所有服务标签 * * @return 服务标签list */ List&lt;String&gt; getServiceTags();&#125; RibbonFilterContextHolder: 123456789101112131415161718192021222324252627282930313233343536 /** * The Ribbon filter context holder. * @author yanjing * date: 2019/9/30 * description: */public class RibbonFilterContextHolder &#123; /** * Stores the &#123;@link RibbonFilterContext&#125; for current thread. */ private static final ThreadLocal&lt;RibbonFilterContext&gt; CONTEXT_HOLDER = new InheritableThreadLocal&lt;RibbonFilterContext&gt;() &#123; @Override protected RibbonFilterContext initialValue() &#123; return new DefaultRibbonFilterContext(); &#125; &#125;; /** * Retrieves the current thread bound instance of &#123;@link RibbonFilterContext&#125;. * * @return the current context */ public static RibbonFilterContext getCurrentContext() &#123; return CONTEXT_HOLDER.get(); &#125; /** * Clears the current context. */ public static void clearCurrentContext() &#123; CONTEXT_HOLDER.remove(); &#125;&#125; DefaultRibbonFilterContext: 1234567891011121314151617181920212223242526272829303132333435 import java.util.List; /** * Ribbon discovery filter context, stores the attributes based on which the server matching will be performed. * * @author yanjing * date: 2019/9/30 * description: */public class DefaultRibbonFilterContext implements RibbonFilterContext &#123; /** * Filter attributes. */ private final List&lt;String&gt; serviceTags = Lists.newArrayList(); @Override public RibbonFilterContext add(String tag) &#123; serviceTags.add(tag); return this; &#125; @Override public RibbonFilterContext remove(String tag) &#123; serviceTags.remove(tag); return this; &#125; @Override public List&lt;String&gt; getServiceTags() &#123; return serviceTags; &#125;&#125; 最后在配置文件中加入以下配置： 指定ribbon加载我们自定义的策略，此处参考了spring-cloud官方文档： gateway根据标签路由在wms-gateway的AuthUrlRsp类中新增access2Grey字段 在wms-gateway的RoleFilter中做如下修改： 其中RibbonFilterConstants： 遇到的问题以及解决方案请求没有路由到指定标签的服务开发环境自测的时候发现一个问题，请求没有按照指定的标签路由，排查发现自定义的RibbonFilterContext中存储的标签列表中存在重复的标签，日志如下： 由此可见，contextTags中出现了俩个grey标签，导致谓词判断执行结果为false。而理论上contextTags中应该不会出现重复的标签。最终排查发现，虽然我们自定义了一套threadlocal变量，但是框架底层使用的线程池会对线程进行复用： 解决方案： 复用zuul维护的RequestContext 在每个请求执行完成时候，将相应的threadlocal变量remove。但是应该在什么时间点remove呢？没有思路，直接查询下zuul的生命周期，ZuulServlet: 我们发现，zuul自身也维护了一套上下文环境变量，并且在请求结束时清空了。因此，我们可以直接复用zuul维护的RequestContext即可。 在每个请求结束时清空自定义上下文 由图可知，无论routing filters成功与否，post filters都会被执行，其实通过刚刚的源码我们也可以验证这个执行流程。所以新增一个post filter,在其中执行清空自定义上下文。 123456789101112131415161718192021222324252627282930313233343536 /** * @author yanjing * date: 2019/10/11 * description: */@Componentpublic class ClearFilter extends ZuulFilter &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public String filterType() &#123; return FilterConstants.POST_TYPE; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; //清除自定义的上下文 logger.info("开始清除自定义的上下文，&#123;&#125;", RibbonFilterContextHolder.getCurrentContext()); RibbonFilterContextHolder.clearCurrentContext(); logger.info("清除自定义的上下文成功"); return null; &#125;&#125; 开发环境没有在配置文件指定ribbon执行自定义的ServiceTagsAwareRule，为何程序还能正常执行？项目在本地运行时，我们在本地的default配置文件中加入了以下代码： 然而在发布开发环境的时候，由于我个人的疏忽，没有将开发环境的配置文件加上上述配置代码，可是令人惊讶的是程序运行正常，和预期结果一致。那么框架又是如何自动加载我们自定义的负载均衡策略的呢？ 原因： 在经过本地调试后，我们仔细看下RibbonDiscoveryRuleAutoConfiguration和RibbonClientConfiguration这俩个文件： 1234567891011121314151617181920 /** * The Ribbon discovery filter auto configuration. * * @author yanjing * date: 2019/9/30 * description: */@Configuration@AutoConfigureBefore(RibbonClientConfiguration.class)@ConditionalOnProperty(value = "ribbon.filter.tags.enabled", matchIfMissing = true)public class RibbonDiscoveryRuleAutoConfiguration &#123; @Bean @ConditionalOnMissingBean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public ServiceTagsAwareRule serviceTagsAwareRule() &#123; return new ServiceTagsAwareRule(); &#125;&#125; 这里主要注意一下@AutoConfigureBefore(RibbonClientConfiguration.class)这句注解，表示该配置会在RibbonClientConfiguration之前进行加载。然后我们再来看下RibbonClientConfiguration： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211/* * Copyright 2013-2014 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.cloud.netflix.ribbon; import java.net.URI; import javax.annotation.PostConstruct; import org.apache.http.client.params.ClientPNames;import org.apache.http.client.params.CookiePolicy;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.cloud.commons.httpclient.HttpClientConfiguration;import org.springframework.cloud.netflix.ribbon.apache.HttpClientRibbonConfiguration;import org.springframework.cloud.netflix.ribbon.okhttp.OkHttpRibbonConfiguration;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import; import com.netflix.client.DefaultLoadBalancerRetryHandler;import com.netflix.client.RetryHandler;import com.netflix.client.config.CommonClientConfigKey;import com.netflix.client.config.DefaultClientConfigImpl;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.ConfigurationBasedServerList;import com.netflix.loadbalancer.DummyPing;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.IPing;import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.PollingServerListUpdater;import com.netflix.loadbalancer.Server;import com.netflix.loadbalancer.ServerList;import com.netflix.loadbalancer.ServerListFilter;import com.netflix.loadbalancer.ServerListUpdater;import com.netflix.loadbalancer.ZoneAvoidanceRule;import com.netflix.loadbalancer.ZoneAwareLoadBalancer;import com.netflix.niws.client.http.RestClient;import com.sun.jersey.api.client.Client;import com.sun.jersey.client.apache4.ApacheHttpClient4; import static com.netflix.client.config.CommonClientConfigKey.DeploymentContextBasedVipAddresses;import static org.springframework.cloud.netflix.ribbon.RibbonUtils.setRibbonProperty;import static org.springframework.cloud.netflix.ribbon.RibbonUtils.updateToHttpsIfNeeded; /** * @author Dave Syer */@SuppressWarnings("deprecation")@Configuration@EnableConfigurationProperties//Order is important here, last should be the default, first should be optional// see https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653@Import(&#123;HttpClientConfiguration.class, OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)public class RibbonClientConfiguration &#123; public static final int DEFAULT_CONNECT_TIMEOUT = 1000; public static final int DEFAULT_READ_TIMEOUT = 1000; @Value("$&#123;ribbon.client.name&#125;") private String name = "client"; // TODO: maybe re-instate autowired load balancers: identified by name they could be // associated with ribbon clients @Autowired private PropertiesFactory propertiesFactory; @Bean @ConditionalOnMissingBean public IClientConfig ribbonClientConfig() &#123; DefaultClientConfigImpl config = new DefaultClientConfigImpl(); config.loadProperties(this.name); config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT); config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT); return config; &#125; @Bean @ConditionalOnMissingBean //不会进行加载，因为我们之前已经在RibbonDiscoveryRuleAutoConfiguration中加载了IRule的子类，也就是我们自定义的ServiceTagsAwareRule public IRule ribbonRule(IClientConfig config) &#123; if (this.propertiesFactory.isSet(IRule.class, name)) &#123; return this.propertiesFactory.get(IRule.class, config, name); &#125; ZoneAvoidanceRule rule = new ZoneAvoidanceRule(); rule.initWithNiwsConfig(config); return rule; &#125; @Bean @ConditionalOnMissingBean public IPing ribbonPing(IClientConfig config) &#123; if (this.propertiesFactory.isSet(IPing.class, name)) &#123; return this.propertiesFactory.get(IPing.class, config, name); &#125; return new DummyPing(); &#125; @Bean @ConditionalOnMissingBean @SuppressWarnings("unchecked") public ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) &#123; if (this.propertiesFactory.isSet(ServerList.class, name)) &#123; return this.propertiesFactory.get(ServerList.class, config, name); &#125; ConfigurationBasedServerList serverList = new ConfigurationBasedServerList(); serverList.initWithNiwsConfig(config); return serverList; &#125; @Bean @ConditionalOnMissingBean public ServerListUpdater ribbonServerListUpdater(IClientConfig config) &#123; return new PollingServerListUpdater(config); &#125; @Bean @ConditionalOnMissingBean //此处加载ribbonLoadBalancer，其中的IRule框架会自行匹配到我们之前已经加载好的ServiceTagsAwareRule public ILoadBalancer ribbonLoadBalancer(IClientConfig config, ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter, IRule rule, IPing ping, ServerListUpdater serverListUpdater) &#123; if (this.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123; return this.propertiesFactory.get(ILoadBalancer.class, config, name); &#125; return new ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList, serverListFilter, serverListUpdater); &#125; @Bean @ConditionalOnMissingBean @SuppressWarnings("unchecked") public ServerListFilter&lt;Server&gt; ribbonServerListFilter(IClientConfig config) &#123; if (this.propertiesFactory.isSet(ServerListFilter.class, name)) &#123; return this.propertiesFactory.get(ServerListFilter.class, config, name); &#125; ZonePreferenceServerListFilter filter = new ZonePreferenceServerListFilter(); filter.initWithNiwsConfig(config); return filter; &#125; @Bean @ConditionalOnMissingBean public RibbonLoadBalancerContext ribbonLoadBalancerContext(ILoadBalancer loadBalancer, IClientConfig config, RetryHandler retryHandler) &#123; return new RibbonLoadBalancerContext(loadBalancer, config, retryHandler); &#125; @Bean @ConditionalOnMissingBean public RetryHandler retryHandler(IClientConfig config) &#123; return new DefaultLoadBalancerRetryHandler(config); &#125; @Bean @ConditionalOnMissingBean public ServerIntrospector serverIntrospector() &#123; return new DefaultServerIntrospector(); &#125; @PostConstruct public void preprocess() &#123; setRibbonProperty(name, DeploymentContextBasedVipAddresses.key(), name); &#125; static class OverrideRestClient extends RestClient &#123; private IClientConfig config; private ServerIntrospector serverIntrospector; protected OverrideRestClient(IClientConfig config, ServerIntrospector serverIntrospector) &#123; super(); this.config = config; this.serverIntrospector = serverIntrospector; initWithNiwsConfig(this.config); &#125; @Override public URI reconstructURIWithServer(Server server, URI original) &#123; URI uri = updateToHttpsIfNeeded(original, this.config, this.serverIntrospector, server); return super.reconstructURIWithServer(server, uri); &#125; @Override protected Client apacheHttpClientSpecificInitialization() &#123; ApacheHttpClient4 apache = (ApacheHttpClient4) super.apacheHttpClientSpecificInitialization(); apache.getClientHandler().getHttpClient().getParams().setParameter( ClientPNames.COOKIE_POLICY, CookiePolicy.IGNORE_COOKIES); return apache; &#125; &#125; &#125; 至此，谜题解开，由于我们优先加载了自定义的ServiceTagsAwareRule，所以RibbonClientConfiguration中默认的ribbonRule不会被加载，最后在加载ribbonLoadBalancer的时候，框架只能匹配到我们自定义的ServiceTagsAwareRule。 最后，我们可以开心的将指向自定义策略的配置省略了！ 参考链接：http://juke.outofmemory.cn/entry/253610 http://juke.outofmemory.cn/entry/253843 http://ju.outofmemory.cn/entry/253845 https://github.com/jmnarloch/ribbon-discovery-filter-spring-cloud-starter https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-ribbon.html https://github.com/Netflix/zuul/wiki/How-it-Works]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>zuul</tag>
        <tag>网关</tag>
        <tag>Netflix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客备份]]></title>
    <url>%2Fposts%2F2dd71a2b%2F</url>
    <content type="text"><![CDATA[一、将本地hexo博客的仓库初始化为git项目注意：检查一下theme文件夹下的主题。例如如果themes/next，此目录下若有.git文件夹，请删除这个.git文件夹。 12//默认已经在项目根路径下git init //初始化本地仓库 二、配置.gitignore文件新建.gitignore（有则忽略），在文件中输入以下内容 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 三、将本地仓库和xxx.github.io仓库的url配对，推送本地仓库文件至远端的hexo分支123456git add .git commit -m "blog hexo"git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上git remote add origin git@github.com:xxx/xxx.github.io.git //xxx为github用户名git push origin hexo //push到Github项目的hexo分支上 四、在其他终端获取hexo仓库。1.从github上拉取hexo分支的代码123git clone -b hexo git@github.com:user/user.github.io.git //将Github中hexo分支clone到本地cd user.github.ionpm install 2.写文章并进行备份和部署1234567//进入user.github.io文件夹,应是hexo分支git pull origin hexo //本地和远端的融合hexo new post "new post name" //写新文章git add sourcegit commit -m "xxx"git push origin hexo //备份hexo g &amp;&amp; hexo d]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于GitHub Pages搭建Hexo博客]]></title>
    <url>%2Fposts%2Fff98e00c%2F</url>
    <content type="text"><![CDATA[介绍Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 准备工作安装Git版本控制软件访问git官方下载页面下载对应终端的git安装包，笔者使用的是macbook,所以下载Mac OS X 版本。下载页面如下图所示，点击下载对应终端的git安装包即可。 安装完毕在命令终端输入git，出现如下提示表示git安装成功。window用户可以使用git bash。 安装nodejs访问nodejs官网下载lts版本的安装包，笔者访问时的版本为10.16.0，直接点击下载安装即可。 安装完毕，在命令行输入node -v和npm -v出现版本信息，表示node安装成功。 创建github仓库创建repository访问github。如果没有账号，请先注册。注册完毕，进入个人中心页面，点击左侧边栏的new按钮，进入创建仓库界面。输入仓库名称，yourname.github.io。点击Create repository完成仓库创建。 注意： yourname要和你的github用户名一致，笔者这里yourname为Jing0017。 仓库后缀必需为.github.io结尾。 请务必遵循这俩个条件，否则后续访问会出现404错误。 设置repository的Github Pages完成创建后，点击Settings，滚动下拉至Github Pages配置模块，配置Source，下拉框选择master分支。如果master branch为灰色，请先按照CodeTab页的教程生成README.md文件，然后在回来设置Github Pages。 生成ssh秘钥为方便后续访问，选择ssh方式克隆仓库，免去每次提交时的用户和密码验证。 在终端（Terminal）输入： 1$ ssh-keygen -t rsa -C "Github的注册邮箱地址" 遇到提示请按Enter，等待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用文本编辑器打开id_rsa.pub复制里面内容。访问这里，点击 New SSH key，将复制的内容粘贴至文本框中。最后点击Add SSH key。 安装配置hexo做完上述准备工作，终于迎来了我们的主角hexo。 具体安装步骤，可以参考官方文档。不想移步的请继续往下看。 下载安装hexo选定博客在本地存放的路径1$ cd &lt;your path&gt; 强调：强烈建议不要 选择需要管理员权限才能创建文件（夹）的文件夹。 安装hexo-cli1$ npm install -g hexo-cli 等待安装完毕，在命令行输入 1$ hexo 若出现下图，说明hexo安装成功： 初始化博客123$ hexo init &lt;folder&gt; // 建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字$ cd &lt;folder&gt;$ npm install // 根据package.json的dependencies配置安装所有的依赖包 配置_config.yml初始化博客之后，我们可以看到项目的基本目录结构： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml里修改博客的基础配置。可以参考官方文档。下面我们具体看一下_config.yml文件全貌。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: # The title of your websitesubtitle: # The subtitle of your websitedescription: # The description of your websiteauthor: # Your namelanguage: # The language of your websitetimezone: # URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com/childroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 完善网站信息(Site)12345678# Sitetitle: 禅心小筑subtitle: 随遇而安 description: 菩提本无树，明镜亦非台。本来无一物，何处惹尘埃。keywords: 技术 生活 修行 求道。author: 随风language: zh-CNtimezone: Asia/Shanghai language和timezone的配置，详细可参考语言规范和时区规范。 注意：language字段配置的zh-CN 必需和相关主题文件夹下 /themes/next/languages里面的国际化文件相匹配，否则配置将不生效，显示默认英文配置。 配置主题hexo的默认主题是 landscape，参看这里可以选择自己心仪的主题，笔者这里选择的是next，安装教程可参看这里。简要步骤如下： 12$ cd &lt;folder&gt; $ git clone https://github.com/theme-next/hexo-theme-next themes/next 然后在_config.yml中配置： 1theme: next 配置部署（Deploy）1234deploy: type: git repo: git@github.com:Jing0017/Jing0017.github.io.git branch: master 此处repo配置为准备工作中我们创建的仓库。选择使用ssh方式克隆。branch选择master分支，和github page的设置相对应。 至此我们完成了hexo的安装与配置。 发表第一篇文章建立分类命令终端输入： 1$ hexo new page "categories" 在/source/categories目录下找到index.md文件打开写入如下内容： 12345---title: 文章分类date: 2019-07-15 11:49:33type: "categories"--- 建立标签同理 1$ hexo new page "tags" 在/source/tags目录下找到index.md文件打开写入如下内容： 12345---title: 标签date: 2019-07-15 11:49:20type: "tags"--- 新建一篇文章新建文章并完成写作1$ hexo new "静夜思" 在/source/_post目录下找到 静夜思.md文件打开写入如下内容： 详细解释如下： 12345678title: 静夜思 //文章的标题date: 2019-07-17 16:54:51categories: 唐诗 //注意:之后有空格，将文章划分到唐诗的分类中tags: 李白 //给文章打上李白的标签床前明月光，疑是地上霜。举头望明月，低头思故乡。 本地访问博客markdown生成html1$ hexo generate //简写 hexo g 此时发现文件目录多了public文件夹，此文件夹下是根据/source/_post/目录下的所有markdown文件生成的html，css，js等静态文件。 启动本地服务1$ hexo server // 简写 hexo s 根据提示访问http://localhost:4000。 发现主页新增了一篇静夜思的文章，切分类为唐诗，标签为李白。 笔者这里已经对主题进行了优化，所以和next的默认样式出入较大。 通过Github Page 访问博客执行hexo 部署命令，将生成的静态文件推送至我们的github仓库(yourname.github.io)。 1$ hexo deploy //简写 hexo d 然后直接访问https://yourname.github.io即可。 通过域名访问hexo博客购置域名从各大域名提供商购置个人域名，笔者之前在阿里万网购置过域名，此处省略域名购置流程。可以自行百度。 Github Pages 配置域名 在仓库的Settingstab页中找到GitHub Pages 将Custom domain 设置为自己的域名。此时可以看到Codetab 页中会生成一个CNAME文件，保存着我们的域名信息。 域名配置DNS解析新增俩条域名解析 记录类型为CNAME，主机记录分别为@和www,记录值填yourname.github.io。等待域名解析生效。 域名解析生效后，直接访问http://你的域名即可访问hexo博客。效果如下： 注意： CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐。 网上推荐的解决方法我比较推荐新增hexo-generator-cname插件实现永久保留。 具体操作如下： 在博客根目录下（source 同级目录） 1$ npm install hexo-generator-cname --save //下载hexo-generator-cname库并将依赖写入package.json 在_config.yml 找到Plugins的注释，在其下方增加: 12Plugins:- hexo-generator-cname :smile:感谢你看到了最后，至此我们完成了hexo博客的搭建。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown For Typora]]></title>
    <url>%2Fposts%2Fb4b05a82%2F</url>
    <content type="text"><![CDATA[OverviewMarkdown is created by Daring Fireball; the original guideline is here. Its syntax, however, varies between different parsers or editors. Typora is using GitHub Flavored Markdown. Block ElementsParagraph and line breaksA paragraph is simply one or more consecutive lines of text. In markdown source code, paragraphs are separated by two or more blank lines. In Typora, you only need one blank line (press Return once) to create a new paragraph. Press Shift + Return to create a single line break. Most other markdown parsers will ignore single line breaks, so in order to make other markdown parsers recognize your line break, you can leave two spaces at the end of the line, or insert &lt;br/&gt;. HeadersHeaders use 1-6 hash (#) characters at the start of the line, corresponding to header levels 1-6. For example: 12345# This is an H1## This is an H2###### This is an H6 In Typora, input ‘#’s followed by title content, and press Return key will create a header. BlockquotesMarkdown uses email-style &gt; characters for block quoting. They are presented as: 1234567&gt; This is a blockquote with two paragraphs. This is first paragraph.&gt;&gt; This is second pragraph. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. In Typora, inputting ‘&gt;’ followed by your quote contents will generate a quote block. Typora will insert a proper ‘&gt;’ or line break for you. Nested block quotes (a block quote inside another block quote) by adding additional levels of ‘&gt;’. ListsInput * list item 1 will create an unordered list - the * symbol can be replace with + or -. Input 1. list item 1 will create an ordered list - their markdown source code is as follows: 123456789## un-ordered list* Red* Green* Blue## ordered list1. Red2. Green3. Blue Task ListTask lists are lists with items marked as either [ ] or [x] (incomplete or complete). For example: 12345- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed You can change the complete/incomplete state by clicking on the checkbox before the item. (Fenced) Code BlocksTypora only supports fences in GitHub Flavored Markdown. Original code blocks in markdown are not supported. Using fences is easy: Input ``` and press return. Add an optional language identifier after ``` and we’ll run it through syntax highlighting: 1234567891011121314Here's an example:```function test() &#123; console.log("notice the blank line before this function?");&#125;```syntax highlighting:```rubyrequire 'redcarpet'markdown = Redcarpet.new("Hello World!")puts markdown.to_html``` Math BlocksYou can render LaTeX mathematical expressions using MathJax. To add a mathematical expression, input $$ and press the ‘Return’ key. This will trigger an input field which accepts Tex/LaTex source. For example:$$\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \\end{vmatrix}$$In the markdown source file, the math block is a LaTeX expression wrapped by a pair of ‘$$’ marks: 1234567$$\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 = \begin&#123;vmatrix&#125;\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\\end&#123;vmatrix&#125;$$ You can find more details here. TablesInput | First Header | Second Header | and press the return key. This will create a table with two columns. After a table is created, putting focus on that table will open up a toolbar for the table where you can resize, align, or delete the table. You can also use the context menu to copy and add/delete individual columns/rows. The full syntax for tables is described below, but it is not necessary to know the full syntax in detail as the markdown source code for tables is generated automatically by Typora. In markdown source code, they look like: 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | You can also include inline Markdown such as links, bold, italics, or strikethrough in the table. Finally, by including colons (:) within the header row, you can define text in that column to be left-aligned, right-aligned, or center-aligned: 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column. Footnotes123You can create footnotes like this[^footnote].[^footnote]: Here is the *text* of the **footnote**. will produce: You can create footnotes like this[^footnote]. [^footnote]: Here is the text of the footnote. Hover over the ‘footnote’ superscript to see content of the footnote. Horizontal RulesInputting *** or --- on a blank line and pressing return will draw a horizontal line. YAML Front MatterTypora now supports YAML Front Matter. Input --- at the top of the article and then press Return to introduce a metadata block. Alternatively, you can insert a metadata block from the top menu of Typora. Table of Contents (TOC)Input [toc] and press the Return key. This will create a “Table of Contents” section. The TOC extracts all headers from the document, and its contents are updated automatically as you add to the document. Span ElementsSpan elements will be parsed and rendered right after typing. Moving the cursor in middle of those span elements will expand those elements into markdown source. Below is an explanation of the syntax for each span element. LinksMarkdown supports two styles of links: inline and reference. In both styles, the link text is delimited by [square brackets]. To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example: 1This is [an example](http://example.com/) inline link. will produce: This is an example inline link. (&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot;&gt;) Internal LinksYou can set the href to headers, which will create a bookmark that allow you to jump to that section after clicking. For example: Command(on Windows: Ctrl) + Click This link will jump to header Block Elements. To see how to write that, please move cursor or click that link with ⌘ key pressed to expand the element into markdown source. Reference LinksReference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link: 12345This is [an example][id] reference-style link.Then, anywhere in the document, you define your link label on a line by itself like this:[id]: http://example.com/ "Optional Title Here" In Typora, they will be rendered like so: This is an example reference-style link. The implicit link name shortcut allows you to omit the name of the link, in which case the link text itself is used as the name. Just use an empty set of square brackets — for example, to link the word “Google” to the google.com web site, you could simply write: 1234[Google][]And then define the link:[Google]: http://google.com/ In Typora, clicking the link will expand it for editing, and command+click will open the hyperlink in your web browser. URLsTypora allows you to insert URLs as links, wrapped by &lt;brackets&gt;. &lt;i@typora.io&gt; becomes &#x69;&#64;&#116;&#121;&#x70;&#111;&#x72;&#97;&#x2e;&#x69;&#x6f;. Typora will also automatically link standard URLs. e.g: www.google.com. ImagesImages have similar syntax as links, but they require an additional ! char before the start of the link. The syntax for inserting an image looks like this: 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") You are able to use drag &amp; drop to insert an image from an image file or your web browser. You can modify the markdown source code by clicking on the image. A relative path will be used if the image that is added using drag &amp; drop is in same directory or sub-directory as the document you’re currently editing. If you’re using markdown for building websites, you may specify a URL prefix for the image preview on your local computer with property typora-root-url in YAML Front Matters. For example, input typora-root-url:/User/Abner/Website/typora.io/ in YAML Front Matters, and then ![alt](/blog/img/test.png) will be treated as ![alt](file:///User/Abner/Website/typora.io/blog/img/test.png) in Typora. You can find more details here. EmphasisMarkdown treats asterisks (*) and underscores (_) as indicators of emphasis. Text wrapped with one * or _ will be wrapped with an HTML &lt;em&gt; tag. E.g: 123*single asterisks*_single underscores_ output: single asterisks single underscores GFM will ignore underscores in words, which is commonly used in code and names, like this: wow_great_stuff do_this_and_do_that_and_another_thing. To produce a literal asterisk or underscore at a position where it would otherwise be used as an emphasis delimiter, you can backslash escape it: 1\*this text is surrounded by literal asterisks\* Typora recommends using the * symbol. StrongA double * or _ will cause its enclosed contents to be wrapped with an HTML &lt;strong&gt; tag, e.g: 123**double asterisks**__double underscores__ output: double asterisks double underscores Typora recommends using the ** symbol. CodeTo indicate an inline span of code, wrap it with backtick quotes (`). Unlike a pre-formatted code block, a code span indicates code within a normal paragraph. For example: 1Use the `printf()` function. will produce: Use the printf() function. StrikethroughGFM adds syntax to create strikethrough text, which is missing from standard Markdown. ~~Mistaken text.~~ becomes Mistaken text. UnderlinesUnderline is powered by raw HTML. &lt;u&gt;Underline&lt;/u&gt; becomes Underline. Emoji 😄Input emoji with syntax :smile:. User can trigger auto-complete suggestions for emoji by pressing ESC key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to Edit -&gt; Emoji &amp; Symbols in the menu bar (macOS). Inline MathTo use this feature, please enable it first in the Preference Panel -&gt; Markdown Tab. Then, use $ to wrap a TeX command. For example: $\lim_{x \to \infty} \exp(-x) = 0$ will be rendered as LaTeX command. To trigger inline preview for inline math: input “$”, then press the ESC key, then input a TeX command. You can find more details here. SubscriptTo use this feature, please enable it first in the Preference Panel -&gt; Markdown Tab. Then, use ~ to wrap subscript content. For example: H~2~O, X~long\ text~/ SuperscriptTo use this feature, please enable it first in the Preference Panel -&gt; Markdown Tab. Then, use ^ to wrap superscript content. For example: X^2^. HighlightTo use this feature, please enable it first in the Preference Panel -&gt; Markdown Tab. Then, use == to wrap highlight content. For example: ==highlight==. HTMLYou can use HTML to style content what pure Markdown does not support. For example, use &lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt; to add text with red color. Embed ContentsSome websites provide iframe-based embed code which you can also paste into Typora. For example: 1&lt;iframe height='265' scrolling='no' title='Fancy Animated SVG Menu' src='http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'&gt;&lt;/iframe&gt; VideoYou can use the &lt;video&gt; HTML tag to embed videos. For example: 1&lt;video src="xxx.mp4" /&gt; Other HTML SupportYou can find more details here.]]></content>
      <categories>
        <category>doc</category>
      </categories>
      <tags>
        <tag>typora</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
